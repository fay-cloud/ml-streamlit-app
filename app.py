import streamlit as st
import joblib
import pandas as pd
import tensorflow as tf
import numpy as np
from datetime import datetime, timedelta
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import load_model # type: ignore
import pickle


# Set page config
st.set_page_config(page_title="NGN/EUR Forecast", page_icon="üíπ")

# Load artifacts with error handling
@st.cache_resource
def load_artifacts():
    try:
        model = load_model('ngn_euro_lstm.h5')
        scaler = joblib.load('ngn_euro_scaler.pkl')
        last_sequence = np.load('last_sequence.npy')
        with open('seq_length.pkl', 'rb') as f:
            seq_length = pickle.load(f)
        return model, scaler, last_sequence, seq_length
    except Exception as e:
        st.error(f"Error loading model artifacts: {str(e)}")
        st.stop()

model, scaler, last_sequence, seq_length = load_artifacts()

# Streamlit UI
st.title("üíπ NGN/EUR Price Prediction")
st.markdown("Predict future exchange rates using our LSTM forecasting model")

# User input with validation
today = datetime.today().date()
input_date = st.date_input(
    "Select prediction date:",
    min_value=today + timedelta(days=1),
    value=today + timedelta(days=7)
)

days_to_predict = (input_date - today).days
if days_to_predict <= 0:
    st.warning("Please select a future date")
    st.stop()

# Initialize prediction sequence
current_sequence = last_sequence[-seq_length:].copy()
predictions = []

# Generate predictions
with st.spinner(f'Forecasting next {days_to_predict} days...'):
    for day in range(days_to_predict):
        # Reshape for model input
        input_data = current_sequence.reshape(1, seq_length, 1)
        
        # Predict next value
        next_pred = model.predict(input_data, verbose=0)[0,0]
        
        # Store the scaled prediction for sequence update
        current_sequence = np.roll(current_sequence, -1)
        current_sequence[-1] = next_pred
        
        # Inverse transform to get actual value
        predicted_value = scaler.inverse_transform([[next_pred]])[0,0]
        predictions.append(predicted_value)

# Get current rate (properly reshaped)
current_rate = scaler.inverse_transform(last_sequence[-1:].reshape(1, -1))[0,0]
final_prediction = predictions[-1] if days_to_predict > 0 else current_rate

# Calculate percentage change
percentage_change = ((final_prediction - current_rate) / current_rate) * 100

# Display results
st.subheader("üîÆ Prediction Result")
col1, col2 = st.columns(2)

with col1:
    st.metric(
        label=f"Predicted NGN/EUR for {input_date.strftime('%b %d, %Y')}",
        value=f"{final_prediction:.2f}",
    )

with col2:
    st.metric(
        label="Change from current",
        value=f"{final_prediction - current_rate:.2f}",
        delta=f"{percentage_change:.1f}%"
    )

# Show prediction trajectory
st.subheader("üìà Forecast Trend")
pred_dates = [today + timedelta(days=i+1) for i in range(days_to_predict)]
forecast_df = pd.DataFrame({
    'Date': pred_dates,
    'NGN/EUR': predictions,
    'Day': range(1, days_to_predict+1)
})

st.line_chart(forecast_df.set_index('Day')['NGN/EUR'])

# Raw data expander
with st.expander("üìä View detailed forecast data"):
    st.dataframe(forecast_df.style.format({
        'NGN/EUR': '{:.2f}',
        'Date': lambda x: x.strftime('%Y-%m-%d')
    }))

# Disclaimer
st.caption("""
‚ö†Ô∏è Note: These predictions are generated by an AI model and should not be considered 
as financial advice. Actual market rates may vary.
""")